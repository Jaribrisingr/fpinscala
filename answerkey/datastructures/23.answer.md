```scala
/*
This function is usually called `zipWith`. The discussion about stack usage from the explanation of `map` also
applies here. By putting the `f` in the second argument list, Scala can infer its type from the previous argument list.
*/
def zipWith[A,B,C](a: MyList[A], b: MyList[B], f: (A,B) => C): MyList[C] = (a,b) match
  case (MyNil, _) => MyNil
  case (_, MyNil) => MyNil
  case (Cons(h1, t1), Cons(h2, t2)) => Cons(f(h1, h2), zipWith(t1, t2, f))

/*
Tail recursive implementation of `zipWith`. 
*/
def zipWith_1[A,B,C](a: MyList[A], b: MyList[B], f: (A,B) => C): MyList[C] =
  @annotation.tailrec
  def loop(a: MyList[A], b: MyList[B], acc: MyList[C]): MyList[C] =
    (a, b) match
      case (MyNil, _) => acc
      case (_, MyNil) => acc
      case (Cons(h1, t1), Cons(h2, t2)) => loop(t1, t2, Cons(f(h1, h2), acc))
  reverse(loop(a, b, MyNil))
```
